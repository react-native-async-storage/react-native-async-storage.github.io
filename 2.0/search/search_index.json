{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async Storage","text":"<p>Async Storage is asynchronous, unencrypted, persistent, key-value storage for your React Native application.</p>"},{"location":"#supported-platform","title":"Supported platform","text":"<ul> <li>Android</li> <li>iOS</li> <li>Web</li> <li>macOS</li> <li>Windows</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>See installation instructions</p>"},{"location":"API/","title":"API","text":""},{"location":"API/#getitem","title":"<code>getItem</code>","text":"<p>Gets a string value for given <code>key</code>. This function can either return a string value for existing <code>key</code> or return <code>null</code> otherwise.</p> <p>In order to store object value, you need to deserialize it, e.g. using <code>JSON.parse()</code>.</p> <p>Note (legacy): you can use optional callback as an alternative for returned promise.</p> <p>Signature:</p> <pre><code>static getItem(key: string, [callback]: ?(error: ?Error, result: ?string) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> resolving with a string value, if entry exists for given <code>key</code>, or <code>null</code> otherwise.</p> <p><code>Promise</code> can also be rejected in case of underlying storage error.</p> <p>Example:</p> <pre><code>getMyStringValue = async () =&gt; {\n  try {\n    return await AsyncStorage.getItem('@key')\n  } catch(e) {\n    // read error\n  }\n\n  console.log('Done.')\n}\n</code></pre> <pre><code>getMyObject = async () =&gt; {\n  try {\n    const jsonValue = await AsyncStorage.getItem('@key')\n    return jsonValue != null ? JSON.parse(jsonValue) : null\n  } catch(e) {\n    // read error\n  }\n\n  console.log('Done.')\n}\n</code></pre> <p> </p>"},{"location":"API/#setitem","title":"<code>setItem</code>","text":"<p>Sets a string <code>value</code> for given <code>key</code>. This operation can either modify an existing entry, if it did exist for given <code>key</code>, or add new one otherwise.</p> <p>In order to store object value, you need to serialize it, e.g. using <code>JSON.stringify()</code>.</p> <p>Note (legacy): you can use optional callback as an alternative for returned promise.</p> <p>Signature:</p> <pre><code>static setItem(key: string, value: string, [callback]: ?(error: ?Error) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> resolving when the set operation is completed.</p> <p><code>Promise</code> can also be rejected in case of underlying storage error.</p> <p>Example:</p> <pre><code>setStringValue = async (value) =&gt; {\n  try {\n    await AsyncStorage.setItem('key', value)\n  } catch(e) {\n    // save error\n  }\n\n  console.log('Done.')\n}\n</code></pre> <pre><code>setObjectValue = async (value) =&gt; {\n  try {\n    const jsonValue = JSON.stringify(value)\n    await AsyncStorage.setItem('key', jsonValue)\n  } catch(e) {\n    // save error\n  }\n\n  console.log('Done.')\n}\n</code></pre> <p> </p>"},{"location":"API/#mergeitem","title":"<code>mergeItem</code>","text":"<p>Merges an existing value stored under <code>key</code>, with new <code>value</code>, assuming both values are stringified JSON.</p> <p>Signature:</p> <pre><code>static mergeItem(key: string, value: string, [callback]: ?(error: ?Error) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> with merged data, if exists, <code>null</code> otherwise.</p> <p>Example:</p> <pre><code>const USER_1 = {\n  name: 'Tom',\n  age: 20,\n  traits: {\n    hair: 'black',\n    eyes: 'blue'\n  }\n}\n\nconst USER_2 = {\n  name: 'Sarah',\n  age: 21,\n  hobby: 'cars',\n  traits: {\n    eyes: 'green',\n  }\n}\n\n\nmergeUsers = async () =&gt; {\n  try {\n    //save first user\n    await AsyncStorage.setItem('@MyApp_user', JSON.stringify(USER_1))\n\n    // merge USER_2 into saved USER_1\n    await AsyncStorage.mergeItem('@MyApp_user', JSON.stringify(USER_2))\n\n    // read merged item\n    const currentUser = await AsyncStorage.getItem('@MyApp_user')\n\n    console.log(currentUser)\n\n    // console.log result:\n    // {\n    //   name: 'Sarah',\n    //   age: 21,\n    //   hobby: 'cars',\n    //   traits: {\n    //     eyes: 'green',\n    //     hair: 'black'\n    //   }\n    // }\n  }\n}\n</code></pre> <p> </p>"},{"location":"API/#removeitem","title":"<code>removeItem</code>","text":"<p>Removes item for a <code>key</code>, invokes (optional) callback once completed.</p> <p>Signature:</p> <pre><code>static removeItem(key: string, [callback]: ?(error: ?Error) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>removeValue = async () =&gt; {\n  try {\n    await AsyncStorage.removeItem('@MyApp_key')\n  } catch(e) {\n    // remove error\n  }\n\n  console.log('Done.')\n}\n</code></pre> <p> </p>"},{"location":"API/#getallkeys","title":"<code>getAllKeys</code>","text":"<p>Returns all keys known to your App, for all callers, libraries, etc. Once completed, invokes <code>callback</code> with errors (if any) and array of keys.</p> <p>Signature:</p> <pre><code>static getAllKeys([callback]: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>getAllKeys = async () =&gt; {\n  let keys = []\n  try {\n    keys = await AsyncStorage.getAllKeys()\n  } catch(e) {\n    // read key error\n  }\n\n  console.log(keys)\n  // example console.log result:\n  // ['@MyApp_user', '@MyApp_key']\n}\n</code></pre> <p> </p>"},{"location":"API/#multiget","title":"<code>multiGet</code>","text":"<p>Fetches multiple key-value pairs for given array of <code>keys</code> in a batch. Once completed, invokes <code>callback</code> with errors (if any) and results.</p> <p>Signature:</p> <pre><code>static multiGet(keys: Array&lt;string&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;, result: ?Array&lt;Array&lt;string&gt;&gt;) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> of array with coresponding key-value pairs found, stored as <code>[key, value]</code> array.</p> <p>Example:</p> <pre><code>getMultiple = async () =&gt; {\n\n  let values\n  try {\n    values = await AsyncStorage.multiGet(['@MyApp_user', '@MyApp_key'])\n  } catch(e) {\n    // read error\n  }\n  console.log(values)\n\n  // example console.log output:\n  // [ ['@MyApp_user', 'myUserValue'], ['@MyApp_key', 'myKeyValue'] ]\n}\n</code></pre> <p> </p>"},{"location":"API/#multiset","title":"<code>multiSet</code>","text":"<p>Stores multiple key-value pairs in a batch. Once completed, <code>callback</code> with any errors will be called.</p> <p>Signature:</p> <pre><code>static multiSet(keyValuePairs: Array&lt;Array&lt;string&gt;&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>multiSet = async () =&gt; {\n  const firstPair = [\"@MyApp_user\", \"value_1\"]\n  const secondPair = [\"@MyApp_key\", \"value_2\"]\n  try {\n    await AsyncStorage.multiSet([firstPair, secondPair])\n  } catch(e) {\n    //save error\n  }\n\n  console.log(\"Done.\")\n}\n</code></pre> <p> </p>"},{"location":"API/#multimerge","title":"<code>multiMerge</code>","text":"<p>Multiple merging of existing and new values in a batch. Assumes that values are stringified JSON. Once completed, invokes <code>callback</code> with errors (if any).</p> <p>Signature:</p> <pre><code>static multiMerge(keyValuePairs: Array&lt;Array&lt;string&gt;&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>const USER_1 = {\n  name: 'Tom',\n  age: 30,\n  traits: {hair: 'brown'},\n};\n\nconst USER_1_DELTA = {\n  age: 31,\n  traits: {eyes: 'blue'},\n};\n\nconst USER_2 = {\n  name: 'Sarah',\n  age: 25,\n  traits: {hair: 'black'},\n};\n\nconst USER_2_DELTA = {\n  age: 26,\n  traits: {hair: 'green'},\n};\n\n\nconst multiSet = [\n  [\"@MyApp_USER_1\", JSON.stringify(USER_1)],\n  [\"@MyApp_USER_2\", JSON.stringify(USER_2)]\n]\n\nconst multiMerge = [\n  [\"@MyApp_USER_1\", JSON.stringify(USER_1_DELTA)],\n  [\"@MyApp_USER_2\", JSON.stringify(USER_2_DELTA)]\n]\n\n\nmergeMultiple = async () =&gt; {\n  let parsedCurrentlyMerged\n\n  try {\n    await AsyncStorage.multiSet(multiSet)\n    await AsyncStorage.multiMerge(multiMerge)\n    const currentlyMerged = await AsyncStorage.multiGet(['@MyApp_USER_1', '@MyApp_USER_2'])\n    parsedCurrentlyMerged = currentlyMerged.map(([key, value]) =&gt; [\n      key,\n      JSON.parse(value),\n    ]);\n  } catch(e) {\n    // error\n  }\n\n  console.log(\n    'parsedCurrentlyMerged',\n    JSON.stringify(parsedCurrentlyMerged, null, 2),\n  );\n  // console.log output:\n  /* \n  [\n    [\n      \"@MyApp_USER_1\",\n      {\n        \"name\": \"Tom\",\n        \"age\": 31,\n        \"traits\": {\n          \"hair\": \"brown\",\n          \"eyes\": \"blue\"\n        }\n      }\n    ],\n    [\n      \"@MyApp_USER_2\",\n      {\n        \"name\": \"Sarah\",\n        \"age\": 26,\n        \"traits\": {\n          \"hair\": \"green\"\n        }\n      }\n    ]\n  ]\n  */\n}\n</code></pre> <p> </p>"},{"location":"API/#multiremove","title":"<code>multiRemove</code>","text":"<p>Clears multiple key-value entries for given array of <code>keys</code> in a batch. Once completed, invokes a <code>callback</code> with errors (if any).</p> <p>Signature:</p> <pre><code>static multiRemove(keys: Array&lt;string&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void)\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>removeFew = async () =&gt; {\n  const keys = ['@MyApp_USER_1', '@MyApp_USER_2']\n  try {\n    await AsyncStorage.multiRemove(keys)\n  } catch(e) {\n    // remove error\n  }\n\n  console.log('Done')\n}\n</code></pre> <p> </p>"},{"location":"API/#clear","title":"<code>clear</code>","text":"<p>Removes whole <code>AsyncStorage</code> data, for all clients, libraries, etc. You probably want to use removeItem or multiRemove to clear only your App's keys.</p> <p>Signature:</p> <pre><code>static clear([callback]: ?(error: ?Error) =&gt; void): Promise\n</code></pre> <p>Returns:</p> <p><code>Promise</code> object.</p> <p>Example:</p> <pre><code>clearAll = async () =&gt; {\n  try {\n    await AsyncStorage.clear()\n  } catch(e) {\n    // clear error\n  }\n\n  console.log('Done.')\n}\n</code></pre>"},{"location":"API/#useasyncstorage","title":"<code>useAsyncStorage</code>","text":"<p>Note: A hooks-like interface that we're experimenting with. This will change in the nearest future to fully leverage Hooks API, so feel free to follow this discussion to learn more.</p> <p>The <code>useAsyncStorage</code> returns an object that exposes all methods that allow you to interact with the stored value.</p> <p>Signature:</p> <pre><code>static useAsyncStorage(key: string): {\n  getItem: (\n    callback?: ?(error: ?Error, result: string | null) =&gt; void,\n  ) =&gt; Promise&lt;string | null&gt;,\n  setItem: (\n    value: string,\n    callback?: ?(error: ?Error) =&gt; void,\n  ) =&gt; Promise&lt;null&gt;,\n  mergeItem: (\n    value: string,\n    callback?: ?(error: ?Error) =&gt; void,\n  ) =&gt; Promise&lt;null&gt;,\n  removeItem: (callback?: ?(error: ?Error) =&gt; void) =&gt; Promise&lt;null&gt;,\n}\n</code></pre> <p>Returns:</p> <p><code>object</code></p> <p>Specific Example:</p> <p>You can replace your <code>App.js</code> with the following to see it in action.</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { useAsyncStorage } from '@react-native-async-storage/async-storage';\n\nexport default function App() {\n  const [value, setValue] = useState('value');\n  const { getItem, setItem } = useAsyncStorage('@storage_key');\n\n  const readItemFromStorage = async () =&gt; {\n    const item = await getItem();\n    setValue(item);\n  };\n\n  const writeItemToStorage = async newValue =&gt; {\n    await setItem(newValue);\n    setValue(newValue);\n  };\n\n  useEffect(() =&gt; {\n    readItemFromStorage();\n  }, []);\n\n  return (\n    &lt;View style={{ margin: 40 }}&gt;\n      &lt;Text&gt;Current value: {value}&lt;/Text&gt;\n      &lt;TouchableOpacity\n        onPress={() =&gt;\n          writeItemToStorage(\n            Math.random()\n              .toString(36)\n              .substr(2, 5)\n          )\n        }\n      &gt;\n        &lt;Text&gt;Update value&lt;/Text&gt;\n      &lt;/TouchableOpacity&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre> <p>In this example:</p> <ol> <li>On mount, we read the value at <code>@storage_key</code> and save it to the state under <code>value</code></li> <li>When pressing on \"update value\", a new string gets generated, saved to async storage, and to the component state</li> <li>Try to reload your app - you'll see that the last value is still being read from async storage</li> </ol>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#install","title":"Install","text":"<p>With npm:</p> <pre><code>npm install @react-native-async-storage/async-storage\n</code></pre> <p>With Yarn:</p> <pre><code>yarn add @react-native-async-storage/async-storage\n</code></pre> <p>With Expo CLI:</p> <pre><code>npx expo install @react-native-async-storage/async-storage\n</code></pre>"},{"location":"Installation/#link","title":"Link","text":""},{"location":"Installation/#android-ios","title":"Android &amp; iOS","text":"<p>Requires React Native 0.60+</p> <p>CLI autolink feature links the module while building the app.</p> <p>On iOS, use CocoaPods to add the native <code>RNAsyncStorage</code> to your project:</p> <pre><code>npx pod-install\n</code></pre>"},{"location":"Installation/#windows","title":"Windows","text":"<p>Requires React Native Windows 0.63+</p> <p>CLI autolink feature links the module while building the app.</p>"},{"location":"Installation/#macos","title":"macOS","text":"<p>Requires React Native macOS 0.63+</p> <ol> <li>Set <code>platform :macos, '10.14'</code> in <code>macos/Podfile</code></li> <li>Install the pods</li> <li>From now on    CLI autolink feature    will link the module while building the app.</li> </ol>"},{"location":"Usage/","title":"Usage","text":"<p>Async Storage can only store <code>string</code> data. In order to store object data, you need to serialize it first. For data that can be serialized to JSON, you can use <code>JSON.stringify()</code> when saving the data and <code>JSON.parse()</code> when loading the data.</p>"},{"location":"Usage/#importing","title":"Importing","text":"<pre><code>import AsyncStorage from '@react-native-async-storage/async-storage';\n</code></pre>"},{"location":"Usage/#storing-data","title":"Storing data","text":"<p><code>setItem()</code> is used both to add new data item (when no data for given key exists), and to modify existing item (when previous data for given key exists).</p>"},{"location":"Usage/#storing-string-value","title":"Storing string value","text":"<pre><code>const storeData = async (value) =&gt; {\n  try {\n    await AsyncStorage.setItem('my-key', value);\n  } catch (e) {\n    // saving error\n  }\n};\n</code></pre>"},{"location":"Usage/#storing-object-value","title":"Storing object value","text":"<pre><code>const storeData = async (value) =&gt; {\n  try {\n    const jsonValue = JSON.stringify(value);\n    await AsyncStorage.setItem('my-key', jsonValue);\n  } catch (e) {\n    // saving error\n  }\n};\n</code></pre>"},{"location":"Usage/#reading-data","title":"Reading data","text":"<p><code>getItem</code> returns a promise that either resolves to stored value when data is found for given key, or returns <code>null</code> otherwise.</p>"},{"location":"Usage/#reading-string-value","title":"Reading string value","text":"<pre><code>const getData = async () =&gt; {\n  try {\n    const value = await AsyncStorage.getItem('my-key');\n    if (value !== null) {\n      // value previously stored\n    }\n  } catch (e) {\n    // error reading value\n  }\n};\n</code></pre>"},{"location":"Usage/#reading-object-value","title":"Reading object value","text":"<pre><code>const getData = async () =&gt; {\n  try {\n    const jsonValue = await AsyncStorage.getItem('my-key');\n    return jsonValue != null ? JSON.parse(jsonValue) : null;\n  } catch (e) {\n    // error reading value\n  }\n};\n</code></pre>"},{"location":"Usage/#more","title":"More","text":"<p>For more examples, head over to API section.</p>"},{"location":"advanced/Backup/","title":"Database backup exclusion","text":""},{"location":"advanced/Backup/#supported-platforms","title":"Supported platforms:","text":"<ul> <li>iOS</li> <li>macOS</li> </ul> <p>Async Storage stores data in <code>Application Support</code> directory, which is backed up by iCloud by default. This can lead to unintentional behavior where data is persisted even after an app re-installation.</p> <p>Async Storage disables that feature by default. </p> <p>In order to enable iCloud backup, open your app's <code>info.plist</code> in Xcode and add boolean entry called RCTAsyncStorageExcludeFromBackup and set its value to NO (NO as no for exclusion).</p> <p>Alternatively, you can open <code>info.plist</code> in editor and add new entry:  <pre><code>+   &lt;key&gt;RCTAsyncStorageExcludeFromBackup&lt;/key&gt;\n+   &lt;false/&gt;\n</code></pre></p>"},{"location":"advanced/BrownfieldIntegration/","title":"Brownfield integration","text":""},{"location":"advanced/BrownfieldIntegration/#supported-platforms","title":"Supported platforms:","text":"<ul> <li>iOS</li> <li>macOS</li> <li>Android</li> </ul>"},{"location":"advanced/BrownfieldIntegration/#ios","title":"iOS","text":"<p>If you're embedding React Native into native application, you can also integrate Async Storage module, so that both worlds will use one storage solution.</p> <p>AsyncStorage can be controlled by the hosting app via the delegate on <code>RNCAsyncStorage</code>:</p> <pre><code>RNCAsyncStorage *asyncStorage = [bridge moduleForClass:[RNCAsyncStorage class]];\nasyncStorage.delegate = self;\n</code></pre>"},{"location":"advanced/BrownfieldIntegration/#the-protocol","title":"The protocol","text":"<p>The delegate must conform to the <code>RNCAsyncStorageDelegate</code> protocol:</p>"},{"location":"advanced/BrownfieldIntegration/#allkeys","title":"allKeys","text":"<pre><code>- (void)allKeys:(RNCAsyncStorageResultCallback)block;\n</code></pre> <p>Returns all keys currently stored. If none, an empty array is returned. Called by <code>getAllKeys</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#mergevalues","title":"mergeValues","text":"<pre><code>- (void)mergeValues:(NSArray&lt;NSString *&gt; *)values\n            forKeys:(NSArray&lt;NSString *&gt; *)keys\n         completion:(RNCAsyncStorageResultCallback)block;\n</code></pre> <p>Merges values with the corresponding values stored at specified keys. Called by <code>mergeItem</code> and <code>multiMerge</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#removeallvalues","title":"removeAllValues","text":"<pre><code>- (void)removeAllValues:(RNCAsyncStorageCompletion)block;\n</code></pre> <p>Removes all values from the store. Called by <code>clear</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#removevaluesforkeys","title":"removeValuesForKeys","text":"<pre><code>- (void)removeValuesForKeys:(NSArray&lt;NSString *&gt; *)keys\n                 completion:(RNCAsyncStorageResultCallback)block;\n</code></pre> <p>Removes all values associated with specified keys. Called by <code>removeItem</code> and <code>multiRemove</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#setvalues","title":"setValues","text":"<pre><code>- (void)setValues:(NSArray&lt;NSString *&gt; *)values\n          forKeys:(NSArray&lt;NSString *&gt; *)keys\n       completion:(RNCAsyncStorageResultCallback)block;\n</code></pre> <p>Sets specified key-value pairs. Called by <code>setItem</code> and <code>multiSet</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#valuesforkeys","title":"valuesForKeys","text":"<pre><code>- (void)valuesForKeys:(NSArray&lt;NSString *&gt; *)keys\n           completion:(RNCAsyncStorageResultCallback)block;\n</code></pre> <p>Returns values associated with specified keys. Called by <code>getItem</code> and <code>multiGet</code> in JS.</p>"},{"location":"advanced/BrownfieldIntegration/#passthrough","title":"passthrough","text":"<pre><code>@optional\n@property (nonatomic, readonly, getter=isPassthrough) BOOL passthrough;\n</code></pre> <p>Optional: Returns whether the delegate should be treated as a passthrough. This is useful for monitoring storage usage among other things. Returns <code>NO</code> by default.</p>"},{"location":"advanced/BrownfieldIntegration/#android","title":"Android","text":"<p>The recommended approach here is to use Kotlin language to leverage coroutines when accessing the storage. Java is also supported (through Kotlin interop), but the approach is more cumbersome.</p>"},{"location":"advanced/BrownfieldIntegration/#prerequisites","title":"Prerequisites","text":"<ol> <li>Next storage feature enabled.</li> <li>Add dependency on <code>coroutines-android</code> in your app's <code>build.gradle</code></li> </ol> <pre><code>dependencies {\n  // other dependencies\n\n\n  // will work with coroutines 1.3.0 and up\n+ implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9\"\n\n}\n</code></pre> <ol> <li>Your library of choice for parsing JSON storage values (since there are strings only)</li> </ol>"},{"location":"advanced/BrownfieldIntegration/#access-storage","title":"Access storage","text":""},{"location":"advanced/BrownfieldIntegration/#kotlin-recommended","title":"Kotlin (recommended)","text":"<p>We use Coroutines to handle asynchronous code. Each method on storage is <code>suspend</code> method, so you need to call it from within a coroutine.</p>"},{"location":"advanced/BrownfieldIntegration/#reading-value","title":"Reading value","text":"<pre><code>suspend fun readValue(ctx: Context, keys: List&lt;String&gt;) {\n    // get instance of the Storage by providing context object\n    val asyncStorage = StorageModule.getStorageInstance(ctx)\n\n    val entries: List&lt;Entry&gt; = asyncStorage.getValues(keys)\n    doSomethingWithValues(entries)\n}\n</code></pre>"},{"location":"advanced/BrownfieldIntegration/#saving-value","title":"Saving value","text":"<pre><code>suspend fun saveValue(ctx: Context) {\n    val asyncStorage = StorageModule.getStorageInstance(ctx)\n\n    val entries = listOf(\n        Entry(\"myKey\", \"myValue\")\n    )\n    asyncStorage.setValues(entries)\n}\n</code></pre>"},{"location":"advanced/BrownfieldIntegration/#java","title":"Java","text":"<p>You can access AsyncStorage form Java, but you're still required to add Kotlin dependencies. There's no one way of accessing the data and there's more than one way to parse it.</p>"},{"location":"advanced/BrownfieldIntegration/#reading-from-storage","title":"Reading from storage","text":"<pre><code>void readStorageValue(Context ctx, String key) {\n    AsyncStorageAccess asyncStorage = StorageModule.getStorageInstance(ctx);\n\n    BuildersKt.launch(GlobalScope.INSTANCE,\n                Dispatchers.getIO(),\n                CoroutineStart.DEFAULT,\n                (scope, continuation) -&gt; {\n                    List&lt;String&gt; keys = new ArrayList&lt;&gt;();\n                    keys.add(key);\n\n                    Continuation&lt;? super List&lt;? extends Entry&gt;&gt; cont = new Continuation() {\n                        @NotNull\n                        @Override\n                        public CoroutineContext getContext() {\n                            return scope.getCoroutineContext();\n                        }\n\n                        @Override\n                        public void resumeWith(@NotNull Object o) {\n                            List&lt;Entry&gt; entries = (List&lt;Entry&gt;) o;\n                            doSomethingWithEntries(entries);\n                        }\n                    };\n\n                    asyncStorage.getValues(keys, cont);\n                    return Unit.INSTANCE;\n                });\n\n}\n</code></pre>"},{"location":"advanced/BrownfieldIntegration/#saving-to-storage","title":"Saving to storage","text":"<pre><code>void saveStorageValue(Context ctx, String key, String value) {\n  AsyncStorageAccess asyncStorage = StorageModule.getStorageInstance(ctx);\n\n  BuildersKt.launch(GlobalScope.INSTANCE,\n                Dispatchers.getIO(),\n                CoroutineStart.DEFAULT,\n                (scope, continuation) -&gt; {\n                    Continuation cont = new Continuation() {\n                        @NotNull\n                        @Override\n                        public CoroutineContext getContext() {\n                            return scope.getCoroutineContext();\n                        }\n\n                        @Override\n                        public void resumeWith(@NotNull Object o) {}\n                    };\n\n                    List&lt;Entry&gt; entries = new ArrayList&lt;&gt;();\n                    Entry entry = new Entry(key, value);\n                    entries.add(entry);\n                    asyncStorage.setValues(entries, cont);\n                    return Unit.INSTANCE;\n                });\n}\n</code></pre>"},{"location":"advanced/DedicatedExecutor/","title":"Dedicator Thread Executor","text":""},{"location":"advanced/DedicatedExecutor/#supported-platforms","title":"Supported platforms:","text":"<ul> <li>Android</li> </ul> <p>Note: This feature is obsolete when Next storage feature is enabled.</p>"},{"location":"advanced/DedicatedExecutor/#motivation","title":"Motivation","text":"<p>This feature would be mostly used in brownfield apps and in edge cases with some android devices. Dedicated thread pool executor makes <code>AsyncStorage</code> use separate thread pool for its tasks execution.</p> <p>Use this feature if <code>THREAD_POOL_EXECUTOR</code> from <code>AsyncTasks</code>:</p> <ul> <li>Is used in your app, so that background tasks are queued most of the time</li> <li>Acts weird on your device (for example, waits for some time before execution)</li> </ul>"},{"location":"advanced/DedicatedExecutor/#how-to-use","title":"How to use","text":"<p>Add a <code>AsyncStorage_dedicatedExecutor</code> property to your <code>android/gradle.properties</code>:</p> <pre><code>AsyncStorage_dedicatedExecutor=true\n</code></pre>"},{"location":"advanced/IncreaseDbSize/","title":"Increasing Storage size","text":""},{"location":"advanced/IncreaseDbSize/#supported-platforms","title":"Supported platforms:","text":"<ul> <li>Android</li> </ul> <p>Note: This feature is obsolete when Next storage feature is enabled.</p>"},{"location":"advanced/IncreaseDbSize/#motivation","title":"Motivation","text":"<p>Current Async Storage's size is set to 6MB. Going over this limit causes <code>database or disk is full</code> error. This 6MB limit is a sane limit to protect the user from the app storing too much data in the database. This also protects the database from filling up the disk cache and becoming malformed (endTransaction() calls will throw an exception, not rollback, and leave the db malformed). You have to be aware of that risk when increasing the database size. We recommend to ensure that your app does not write more data to AsyncStorage than space is left on disk. Since AsyncStorage is based on SQLite on Android you also have to be aware of the SQLite limits.</p>"},{"location":"advanced/IncreaseDbSize/#increase-limit","title":"Increase limit","text":"<p>Add a <code>AsyncStorage_db_size_in_MB</code> property to your <code>android/gradle.properties</code>:</p> <pre><code>AsyncStorage_db_size_in_MB=10\n</code></pre> <p>Now you can define the new size in MB. In this example, the new limit is 10 MB.</p>"},{"location":"advanced/Jest-integration/","title":"Jest integration","text":"<p>Async Storage module is tightly coupled with its <code>NativeModule</code> part - it needs a running React Native application to work properly. In order to use it in tests, you have to provide its separate implementation. Follow these steps to add a mocked <code>Async Storage</code> module.</p>"},{"location":"advanced/Jest-integration/#using-async-storage-mock","title":"Using Async Storage mock","text":"<p>You can use one of two ways to provide mocked version of <code>AsyncStorage</code>:</p>"},{"location":"advanced/Jest-integration/#with-mocks-directory","title":"With mocks directory","text":"<ol> <li>In your project root directory, create    <code>__mocks__/@react-native-async-storage</code> directory.</li> <li>Inside that folder, create <code>async-storage.js</code> file.</li> <li>Inside that file, export <code>Async Storage</code> mock.</li> </ol> <pre><code>export * from \"@react-native-async-storage/async-storage/jest/async-storage-mock\";\n</code></pre>"},{"location":"advanced/Jest-integration/#with-jest-setup-file","title":"With Jest setup file","text":"<ol> <li>In your Jest config (probably in <code>package.json</code>) add setup files location:</li> </ol> <pre><code>\"jest\": {\n  \"setupFiles\": [\"./path/to/jestSetupFile.js\"]\n}\n</code></pre> <ol> <li>Inside your setup file, set up Async Storage mocking:</li> </ol> <pre><code>jest.mock(\"@react-native-async-storage/async-storage\", () =&gt;\n  require(\"@react-native-async-storage/async-storage/jest/async-storage-mock\")\n);\n</code></pre>"},{"location":"advanced/Jest-integration/#testing-with-mock","title":"Testing with mock","text":"<p>Each public method available from <code>Async Storage</code> is a mock function, that you can test for certain condition, for example, if <code>.getItem</code> has been called with a specific arguments:</p> <pre><code>it(\"checks if Async Storage is used\", async () =&gt; {\n  await asyncOperationOnAsyncStorage();\n\n  expect(AsyncStorage.getItem).toBeCalledWith(\"myKey\");\n});\n</code></pre>"},{"location":"advanced/Jest-integration/#overriding-mock-logic","title":"Overriding Mock logic","text":"<p>You can override mock implementation, by replacing its inner functions:</p> <pre><code>// somewhere in your configuration files\nimport AsyncStorageMock from \"@react-native-async-storage/async-storage/jest/async-storage-mock\";\n\nAsyncStorageMock.multiGet = jest.fn(([keys], callback) =&gt; {\n  // do something here to retrieve data\n  callback([]);\n});\n\nexport default AsyncStorageMock;\n</code></pre> <p>You can check its implementation to get more insight into methods signatures.</p>"},{"location":"advanced/Limits/","title":"Known storage limits","text":""},{"location":"advanced/Limits/#android","title":"Android","text":"<p>AsyncStorage for Android uses SQLite for storage backend. While it has its own size limits, Android system also have two known limits: total storage size and per-entry size limit.</p> <ul> <li> <p>Total storage size is capped at 6 MB by default. You can increase this size by specifying a new size using feature flag. </p> </li> <li> <p>Per-entry is limited by a size of a WindowCursor, a buffer used to read data from SQLite. Currently it's size is around 2 MB.   This means that the single item read at one time cannot be larger than 2 MB. There's no supported workaround from AsyncStorage.    We suggest keeping your data lower than that, by chopping it down into many entries, instead of one massive entry.   This is where <code>multiGet</code> and <code>multiSet</code> APIs can shine.</p> </li> </ul>"},{"location":"advanced/Next/","title":"Next storage implementation","text":""},{"location":"advanced/Next/#supported-platforms","title":"Supported platforms:","text":"<ul> <li>Android</li> </ul>"},{"location":"advanced/Next/#motivation","title":"Motivation","text":"<p>Current implementation of persistence layer is created using SQLiteOpenHelper,  a helper class that manages database creation and migrations. Even if this approach is powerful, the lack of compile time query verification and a big boilerplate of mapping SQLite queries  to actual values make this implementation prone to many errors.</p> <p>This Async Storage feature improves the persistence layer, using modern approaches to access SQLite (using Room), to reduce possible anomalies to the minimum.  On top of that, it allows accessing AsyncStorage from the native side, useful in Brownfield integration.</p>"},{"location":"advanced/Next/#migration","title":"Migration","text":"<p>This feature requires no migration from the developer perspective - the current database will be recreated (based on the current one), meaning user won't lose any data if you decide to opt in. There's a small drawback to know - the database \"recreation\" happens only once. </p>"},{"location":"advanced/Next/#how-it-works","title":"How it works","text":"<p>The new database (the one used by this feature) will be created based on the current database file, if the new one does not exist yet.  If we detect that there's already the new database on the device, recreation will not kick in.</p>"},{"location":"advanced/Next/#why-is-it-important","title":"Why is it important","text":"<p>Let's say you enabled the feature for the first time - recreation kicks in and the old database file is untouched. If you decide to disable the feature, your users will be back using old database. No data migrations is happening from new to old database file. When you enable the feature again, the new database is not recreated, because it already exists, and no data is copied over.</p>"},{"location":"advanced/Next/#enable","title":"Enable","text":""},{"location":"advanced/Next/#add-config-flag","title":"Add config flag","text":"<p>In your project's <code>android</code> directory, locate <code>gradle.properties</code> file (if it does not exist, create one) and add the line: <pre><code>AsyncStorage_useNextStorage=true\n</code></pre></p>"},{"location":"advanced/Next/#react-native-073","title":"React Native &lt; 0.73","text":"<p>For React Native below version 0.73, you need to apply Kotlin plugin to your project. In your project's android directory, locate root build.gradle file. Add Kotlin dependency to the buildscript:</p> <pre><code> buildscript {\n     ext {\n         // other extensions\n+        kotlinVersion = '1.9.24'\n     }\n\n     dependencies {\n         // other dependencies\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion\"\n     }\n }\n</code></pre>"},{"location":"advanced/Next/#configuration","title":"Configuration","text":"<p>Kotlin version</p> <p>Next storage is tested against Kotlin version <code>1.9.24</code>.  You can specify different version, in one of two ways:</p> <ul> <li>add <code>kotlinVersion</code> extension to the <code>rootProject</code>:</li> </ul> <pre><code>rootProject.ext.kotlinVersion = '1.9.24'\n</code></pre> <ul> <li>specify <code>AsyncStorage_kotlinVersion</code> in <code>gradle.properties</code>:</li> </ul> <pre><code>AsyncStorage_kotlinVersion=1.9.24\n</code></pre> <p>Room</p> <p>Next AsyncStorage uses Room persistence library to store data. Currently, tested version is <code>2.6.1</code>. You can specify different version, by adding a flag to <code>gradle.properties</code>:</p> <pre><code>AsyncStorage_next_roomVersion=2.6.1\n</code></pre> <p>KSP is enabled for symbol processing for the Room library. KSP version will be selected based on Kotlin version in your project. If you want to use different KSP version, you can set a property in <code>gradle.properties</code>:</p> <pre><code>AsyncStorage_next_kspVersion=1.9.24-1.0.20\n</code></pre>"},{"location":"advanced/Next/#notable-changes","title":"Notable changes","text":"<p>Alongside of a warning regarding <code>key</code>/<code>value</code>, errors are thrown when:</p> <ul> <li>Your <code>key</code> is <code>null</code> or <code>not a string</code></li> <li>You provide value that is <code>not a string</code> </li> </ul>"},{"location":"advanced/Where-data-stored/","title":"Where your data is stored","text":"<ul> <li>Android - SQLite</li> <li>iOS - small values (not exceeding 1024 characters) are serialized and stored in a common <code>manifest.json</code> file, while larger values are stored in individual, dedicated files (named as MD5 hashed <code>key</code>)</li> <li>macOS - Same as iOS</li> <li>Web - window.localStorage</li> <li>Windows - SQLite</li> </ul>"},{"location":"debugging/communityPackages/","title":"Community Packages","text":""},{"location":"debugging/communityPackages/#flipper","title":"Flipper","text":"<p>For projects that use Flipper, there is a Flipper plugin called Advanced Async Storage. The plugin provides basic CRUD operations on Async Storage.</p>"},{"location":"debugging/communityPackages/#non-flipper","title":"Non Flipper","text":"<p>For the projects which aren't using Flipper, you can use the React Native Debugger which comes with a built-in Async Storage support. The debugger allows to print the Async Storage content to the console, and clear it completely.</p>"},{"location":"help/Troubleshooting/","title":"Troubleshooting","text":""},{"location":"help/Troubleshooting/#async-await-doesnt-resolve","title":"Async await doesn't resolve","text":"<p>If you're having issues with <code>getItem()</code> and friends not resolving, check if <code>inlineRequires</code> is enabled in <code>metro.config.js</code>:</p> <pre><code>module.exports = {\n  transformer: {\n    getTransformOptions: async () =&gt; ({\n      transform: {\n        experimentalImportSupport: false,\n        inlineRequires: true,\n      },\n    }),\n  },\n};\n</code></pre> <p>If disabling it resolves the issue, it's likely that you hit a circular import chain. You can try excluding <code>@react-native-async-storage/async-storage</code> from being inlined:</p> <pre><code> module.exports = {\n   transformer: {\n     getTransformOptions: async () =&gt; ({\n       transform: {\n         experimentalImportSupport: false,\n         inlineRequires: true,\n+        nonInlinedRequires: [\n+          \"@react-native-async-storage/async-storage\",\n+          'React',\n+          'react',\n+          'react-native',\n+        ],\n       },\n     }),\n   },\n };\n</code></pre> <p>If this doesn't resolve the issue, you need to figure out what is causing the cyclic chain. There are tools, such as @rnx-kit/metro-plugin-cyclic-dependencies-detector, that can help you debug this.</p>"},{"location":"help/Troubleshooting/#ios-cocoapods-issues","title":"[iOS] CocoaPods issues","text":"<ol> <li>Delete the <code>node_modules</code> folder(s) from your project</li> <li>Run <code>yarn</code> or <code>npm install</code></li> <li>If you're using CocoaPods:</li> <li>Make sure your <code>Podfile</code> does not have an entry for <code>RNCAsyncStorage</code>.</li> <li><code>pod install</code></li> <li><code>pod update RNCAsyncStorage</code></li> <li>Open your Xcode project</li> <li>Press \u21e7\u2325\u2318K to clean your build folder</li> <li>Build and run your project</li> </ol> <p>Note that every time <code>@react-native-async-storage/async-storage</code> gets updated, you must also run <code>pod update RNCAsyncStorage</code> otherwise you'll still be using the previous version.</p>"},{"location":"help/Troubleshooting/#ios-fatal-error-reactrctbridgemoduleh-file-not-found","title":"[iOS] fatal error: 'React/RCTBridgeModule.h' file not found","text":"<pre><code>info In file included from /~/@react-native-async-storage/async-storage/ios/RNCAsyncStorage.m:8:\n/~/@react-native-async-storage/async-storage/ios/RNCAsyncStorage.h:8:9: fatal error: 'React/RCTBridgeModule.h' file not found\n\ninfo #import &lt;React/RCTBridgeModule.h&gt;\n             ^~~~~~~~~~~~~~~~~~~~~~~~~\n\ninfo 1 error generated.\n</code></pre> <ul> <li> <p>Make sure that you've run <code>pod install</code> or <code>pod update RNCAsyncStorage</code> (see   also CocoaPods issues).</p> </li> <li> <p>Make sure that <code>React</code> dependencies are not removed from projects. Without   the target dependency set, Xcode may build things out of order and the React   headers will not be installed when AsyncStorage is built.</p> </li> </ul> <pre><code>post_install do |installer|\n  installer.pods_project.targets.each do |target|\n    if target.name == \"React\"\n      target.remove_from_project\n    end\n  end\nend\n</code></pre> <ul> <li>Try switching back to the legacy build system in Xcode. You can find it in   File &gt; Project/Workspace Settings sheet.</li> </ul>"},{"location":"help/Troubleshooting/#rncasyncstorage-nativemodule-asyncstorage-is-null","title":"[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null","text":""},{"location":"help/Troubleshooting/#ios","title":"iOS","text":"<p>This error means that AsyncStorage was unable to find its native module. This occurs because AsyncStorage was not linked into the final app bundle.</p> <p>Make sure that you've run <code>pod install</code> or <code>pod update RNCAsyncStorage</code> (see also CocoaPods issues).</p>"}]}